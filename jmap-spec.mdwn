##### JSON Mail Access Protocol Specification (JMAP) #####

<div class="author">v. 2014.02.05 :: Editor – <a href="mailto:editor@jmap.io">Neil Jenkins</a>, <a href="https://www.fastmail.fm">FastMail</a></div>

<a href="https://github.com/neilj/jmap"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"></a>

<div id="tocwrapper"><!-- toc --></div>

1. Introduction
===============

What is JMAP?
--------------

JMAP is a new JSON-based API for synchronising a mail client with a mail server.
It is intended as a replacement for IMAP. The specification is based on the API
currently used by [FastMail](https://www.fastmail.fm)'s web app.  It aims to be
compatible with the IMAP data model, so that it can be easily implemented on a
server that currently supports IMAP, but allows for reduced data usage and more
efficient synchronisation, bundling of requests for latency mitigation and is
generally much easier to work with than IMAP.

This is not a final version. Parts are imprecise, incomplete, or could simply be
done better in another way. Please [send feedback](mailto:editor@jmap.io) with
any suggestions, corrections or other comments. In particular, please see the
sections marked "Discussion points" below, for areas I am interested in feedback
on.

### Why is it not REST based?

In one word, speed. When you have a high latency connection (such as on a mobile
phone, or even wired connections from the other side of the world), the extra
round trips required for a REST-based protocol can make a huge impact. This is
espcially an issue when you have an order-dependency in your API calls and you
need to make sure one has finished before the other can be run (for example when
you mutate the state of a message then want to fetch the changes to a mailbox
containing the message). In the JMAP format described below, this can be done in
a single round trip. A REST-based version would require two full round trips for
the same operation.

### Why is it not a binary protocol?

A binary protocol would be arguably more compact and faster to encode/parse.
However, history has shown text-based protocols are much easier to debug, and by
using an existing widely-used encoding format (JSON) we make it much easier for
developers to use this protocol. No need to write new custom, error-prone
parsers. The difference in speed is likely to be minimal, especially if you GZIP
the exchange and use WebSockets instead of HTTP.

Transport and Authentication
----------------------------

The JSON may be exchanged between client and server over either HTTP or the
[WebSocket](http://tools.ietf.org/html/rfc6455) protocol. In both cases SSL
should be used.

For HTTP access, an email/password can be used with simple HTTP Authentication.
If authorisation fails, a 401 response code with no content will be returned.

Implementations may also to choose to support OAuth (how this integrates is not
defined in this spec).

#### !Todo:

* There should be a way to lookup which protocols are supported and at what URL
  they can be accessed for a domain using DNS, to allow clients to set
  themselves up with just an email address and password.
* SSL support should be mandated?
* HTTP support should probably be mandatory, WebSocket support optional?
* The authentication mechanism for WebSocket needs to be defined.

The structure of an exchange
----------------------------

An API call consists of a (UTF-8 encoded of course) JSON array. Each element in
this array will be another array and will constitute a method call. The first
item in these subarrays is the name of the method being called on the server,
the second item is a JSON object containing *named* arguments for that method.
The third (and optional) item is a client id, to be echoed back with the
responses emitted by that method call (as we'll see lower down, it's not so
much RPC as message passing, and a method may return 0, 1 or many messages,
especially as some methods make implicit calls to other ones).

Example query:

    [
      ["method1", {"arg1": "arg1data", "arg2": "arg2data"}, "#1"],
      ["method2", {"arg1": "arg1data"}, "#2"],
      ["method3", {}, "#3"]
    ]

The method calls must be processed in order. Each API call (which, as we
showed, may contain multiple method calls) receives a single JSON response in
exactly the same format. The output of the methods must be added to the array in
the same order in which the methods are processed.

Example response:

    [
      ["responseFromMethod1", {"arg1": 3, "arg2": "foo"}, "#1"],
      ["responseFromMethod2", {"isBlah": true}, "#2"],
      ["anotherResponseFromMethod2", {"data": 10, "yetmoredata": "Hello"}, "#2"]
    ]

Possible errors are specified in each method description. Any errors must be
inserted at the current point in the response and any further method calls
should then be processed as normal. If an unknown method is called, return an
`unknownMethod` error response and continue processing the next method call as
normal.

As always, be strict (paranoid) about data received from the client. Arguments
need to be checked for validity; a malicious user could attempt to find an
exploit through the API. In case of invalid arguments (unknown/insufficient/
wrong type for data etc.) the server should send an invalidArguments error (see
the Error section below) and skip to the next method call.

Concurrency
-----------

The state of the user's email must not change during a single method call
(except due to that method call itself), but may change in between method calls.
This is to ensure the client always sees a consistent view of the data. The
easiest way to do this is a per-user lock that must be held for the duration of
each method call.

The email data model
--------------------

A mailbox is a named set of emails. In an IMAP-backed system, a message must
always belong to one, and only one, mailbox at a time – mailboxes correspond to
folders. In JMAP, however, the only requirement is that the message appears in
**at least one** mailbox. Thus, in label-based systems such as GMail, the same
message may appear in more than one mailbox.

Each email must therefore have an id which is unique for all messages the user
may be able to access (thus, it must be unique across users with shared
folders, but if no  sharing is allowed may be only unique to the user).
IMAP-compatible backends will assign a 32-bit unsigned integer uid on creation
within a mailbox and may choose to use a message id of the format
`"f${mailboxId}u${uid}"`. However, the actual string is opaque to the client,
so if the server already has a different mechanism for allocating unique ids to
messages, it can use this instead. There is no requirement for implementing a
sequential UID numbering system.

Each message has 4 mutable boolean "flags" stored with it, each with a direct
equivalent in IMAP. In JMAP these flags are called:

* **isUnread**: Has the email not yet been read (seen)?
* **isFlagged**: Has the email been flagged (starred, or pinned)?
* **isDraft**: Is the email a draft?
* **isAnswered**: Has the email been answered (replied to)?

A number of custom labels may also be associated with the email.

For compatibility with IMAP, emails are immutable other than flags/labels. To
change anything else, the email must be deleted and a new one created (which
will get a different message id). Also for compatibility with IMAP, moving a
message to a new mailbox may (but doesn't have to) change the id of the message.

Each time an email is changed (created, flag change, deleted), it is assigned a
new modseq (modification sequence) number, an unsigned 63-bit integer. If the
server supports conversations then, unlike in IMAP, there needs to be a single
modseq counter across the whole user, not per mailbox (this is, however,
completely backwards compatible with IMAP). A method that mutates the state
(e.g. changing the unread status of a message) may increment the modseq once
then apply that new modseq to all messages affected by the change, or may
increase multiple times; this is implementation-dependent.

Unlike IMAP, there is no \Deleted deletion model. All mailbox related methods
must act as though messages marked \Deleted do not exist: they must not be
returned as part of any call and they must not be included in any `total`
count. If using an IMAP-compatible backing store, the server may choose to
implement this by adding an implicit `NOT \Deleted` search term to everything,
or by expunging immediately anything marked \Deleted or any other method it
chooses (at FM, we ensure all \Deleted messages are expunged).

Servers implementing an IMAP-style UID system, and using that UID as part of
the message ID, must be able to handle a uid validity change by assigning all
affected mailboxes and messages new ids (essentially to the client this appears
as though they have been deleted and new ones have been created, which by
chance happen to contain the same messages). This will require a lot of data to
be resynced, but is expected to be rare in practice.

Conversations
-------------

Related messages are grouped into conversations. When getting a message list
with conversations enabled, only the first message in the list in a
conversation (given the current sort order) is returned; all others are treated
as though they do not exist as far as the message listing is concerned and do
not count towards the total count for the list.

Suppose a new message arrives that is part of a conversation already listed: if
it is earlier in the current sort order it is treated as an addition of this
message and a deletion of the previous from the mailbox. If it is lower in the
current sort order it is treated as a flag update of the number of other
messages associated with the current message representing this conversation.
The algorithms below all follow this model.

Messages in the Trash folder should not be threaded with messages outside the
trash folder, so that a user can delete a single message out of a conversation.
This means moving a message to a different mailbox may change its conversation
id.

#### !Discussion Point:

Should conversation support be optional? Probably, which
means we probably should have a getCapabilities method.

The Number datatype
-------------------

The JSON datatypes are very limited and correspond to those found in JavaScript.
A `Number` in JavaScript is represented as a signed double (64-bit floating
point). However, except where explicitly specified, all `Number`s used in this
API may be represented as unsigned 32-bit integers. A server or client may rely
on this for internal optimisation.

The Date datatype
-----------------

Where the API specifies a Date as a type, it means a string in the following
format: `YYYY-MM-DDThh:mm:ssZ`, e.g. `"2013-10-30T14:12:00Z"`. All dates must
be in UTC time.

2. Mailbox/message retrieval methods
====================================

## getMailboxes

### Arguments:

- state: String (optional)
    (An opaque string returned by the server from this call, can be used to
    omit mailboxList from the response if nothing has changed.)

### Description:

Returns a list of all mailbox objects. If a state string is supplied as an
argument and it is the same as the current state (i.e. nothing has changed),
the mailboxList argument should be omitted from the response.

In an IMAP server, each mailbox must have a uid validity value. One way to
produce a state string is to hash all these together using sha1 or some other
suitable hash function. We can detect whenever any of the uid validities
change, or a mailbox is created or destroyed, simply by comparing the single
value. If making a stateless proxy implementation of the api on top of an IMAP
server, you could implement mailboxId as Full Mailbox Name + uid validity (e.g.
"Folder.Subfolder356150234"), however it would be more efficient to create a
shorter id (e.g. sequential numbering) in the server itself. The id for a
mailbox must be unique and never reused again for another mailbox of the same
user (or that might be visible to the user, if shared mailboxes are supported).

If not constrained to just proxying a pure IMAP server, a better state string
than a hash of the UID validities would be to increment and store the user
modseq whenever a mailbox is created, deleted or has a property updated.

In GMail, or other systems which have a label-only storage approach, you can
still return all the labels as mailboxes (plus an "All mail" mailbox). The
effect of this is described in the relevant methods.

The permissions object maps to the IMAP permissions model.

### Response name:

mailboxes

### Arguments:

- state: `String`
- list: `Array` of `Mailbox Object`s
    (omitted if no change in state)

Where a `Mailbox Object` is:

    {
      id: String,            // Unique id for identifying this mailbox
      name: String,          // User-visible name, e.g. "Inbox"
      parentId: String|null, // Mailbox id for the parent of this mailbox.
                             // Has value null if this mailbox is at the top
                             // level.
      role: String,          // Identifies system mailboxes. Allowed values are:
                             // 'inbox'/'drafts'/'sent'/'trash'/'spam'/'archive'
                             // or '' (the empty string) for user-defined ones.
      isOwn: Boolean,        // Does the folder belong to the user?
      // If a shared folder (property not present otherwise; presume all true).
      // The permissions map to IMAP ACLs:
      permissions: {
        // May get a list of messages in the folder
        mayRead: Boolean,        // ACLs: (lookup & read)
        // May set the seen flag on messages in the folder
        mayUpdateSeen: Boolean,  // ACL: seen.
        // May set other flags on messages in the folder
        mayUpdateFlags: Boolean, // ACL: write
        // May move/copy messages into the folder
        mayInsert: Boolean,      // ACL: insert
        // May delete or move messages out of the folder
        mayDelete: Boolean,      // ACLs: (delete messages & expunge)
        // May create a sub folder of the folder
        mayCreateSub: Boolean,   // ACL: create
        // May rename or delete the folder
        isDeletable: Boolean     // ACL: delete
      }
    }

Example response where the mailboxes are unchanged:

    [ "mailboxes", { "state": "fea89ab" } ]

--------------------------------------------------------------------------------

## getMailboxCounts

### Arguments:

- state: `String` (optional)

### Description:
  If state is supplied, find all mailboxes whose unread or total count
  have changed since this state and return the new total/unread message and
  conversation counts in each of these mailboxes. Otherwise, return the
  total/unread counts for all mailboxes.

  A conversation counts as unread if there is any non-draft message in it in any
  folder which is unread. So if a conversation has a message in Inbox which is
  unread and another message in Sent which is read, it will contribute 1 to the
  unread count of both of these folders. Draft messages should be ignored when
  determining the unread count of a conversation (i.e. if a message has the
  \Draft flag set it does not count towards the unread total for that
  conversation, even if it does not have a \Seen flag).

### Response name:
  mailboxCounts

### Arguments:
- state: `String`
    (used by the server to calculate delta in unread count)
- counts: `Object` of `String` (folder id) -> `Counts Object`

where a Counts Object is:

    {
      totalMessages: Number,
      unreadMessages: Number,
      totalConversations: Number,
      unreadConversations: Number
    }

Example response:

    ['mailboxUnreadCounts', {
      "state": "ae65333",
      "counts": {
        "f23": {
          "totalMessages": 23,
          "unreadMessages": 10,
          "totalConversations": 10,
          "unreadConversations": 10
        },
        "f52": {
          "totalMessages": 1001,
          "unreadMessages": 0,
          "totalConversations": 23,
          "unreadConversations": 2
        }
      }
    }]

### !Discussion points
- Should the getMailboxCounts method be separate, or should the counts be
  returned as part of getMailboxes? If so, do we add a `propertes` argument
  like in getMessages?

--------------------------------------------------------------------------------

## setMailboxes

### Arguments:

- state: `String`
- create: clientId -> Mailbox Object map. (optional)
- update: clientId -> partial Mailbox Object map. (optional)
- destroy: clientId -> mailbox id map. (optional)

Example request:

    ["setMailboxes", {
      state: "4123",
      create: {
        '#45': {
          name: 'My new folder',
          role: '',
          parentId: null,
          isOwn: true,
          permissions: {
            mayRead: true,
            mayUpdateSeen: true,
            mayUpdateFlags: true,
            mayInsert: true,
            mayDelete: true,
            mayCreateSub: true,
            isDeletable: true,
          }
        }
      }
      update: {
        '#32': {
          id: 'f3',
          name: 'The new name'
        }
      }
    }]

A clientId is an id for the mailbox assigned by the client. To update an
object, you only need specify the id property + any properties which have
changed.

### Description:

If the state does not match the current state, push a
mailboxesSet response onto the output, consisting of:

    ["mailboxesSet", {
      notCreated: Object.keys( args.create ),
      notUpdated: Object.keys( args.update ),
      notDestroyed: Object.keys( args.destroy )
    }]

Then return a validity error (see errors section at bottom of this document).

Otherwise, *conceptually*, what is happening is quite straight-forward:

1. *create*: For each Mailbox Object in the create map, create a new mailbox
   with properties taken from the object. Ignore any mailboxId property (and
   if the server chooses, ignore any role property, otherwise set the role
   and remove the role from all other folders).
2. *update*: For each Mailbox Object in the update map, extract the mailboxId
   property and look up the corresponding mailbox object. For all other
   key/value pairs in the Mailbox Object, set the value on the mailbox object
   (except if the key role, which is read only). The parentId value is also
   read-only if the mailbox has a role attribute (as system folders must be
   top level). Reject permanently if an attempt to write to them is made.
3. *destroy*: For each mailboxId in the clientId -> mailboxId map, destroy the
   mailbox with the corresponding Id, permanently deleting all messages
   contained therein. At the point of destruction, the mailbox should not
   contain any subfolders; these should all have been destroyed or moved out
   of the folder first; reject permanently the destroy command if not. The
   server must also permanently reject any attempt to destroy the role=inbox
   folder and may also reject any attempt to delete other folders (ideally
   the client should be informed of this via the permissions).

If implementing as a proxy to a pure IMAP store, changes to name/parentId
mean a rename, and creates/updates/destroys must be ordered correctly to make
this work.

All values must be checked for validity. Folder names may have a number of
restrictions that must be checked against.

Each entry in the create/update/destroy hashes is considered an atomic unit by
the client. It is permissible for the server to commit some of the changes but
not others, however it is not permissible to only commit part of a change
(e.g. update the name but not the parent if both are supplied in the update
object).

The server must ensure, that after committing all of the changes the tree of
mailboxes is consistent (no circular references or references to
destroyed/non-existent mailboxes).

### Response name:

mailboxesSet

### Arguments:

- created: clientId -> mailboxId map (optional)
    (Mailbox ids are assigned by the server. For each successfully created
     mailbox, add an entry mapping its clientId to this new mailboxId)
- updated: clientId list (optional)
    (list of the clientIds of all successfully updated mailbox objects)
- destroyed: clientId list (optional)
    (list of the clientIds of all successfully destroyed mailbox objects)
- notCreated: clientId list (optional)
    (list of all client ids for which the create failed temporarily)
- notUpdated: clientId list (optional)
    (list of all client ids for which the update failed temporarily)
- notDestroyed: clientId list (optional)
    (list of all client ids for which the destroy failed temporarily)
- error: clientId list (optional)
    (list of all client ids for which the create/update/destroy failed
     permanently, e.g. if an update rename used illegal characters etc.)
- oldState: `String`
    (this should be identical to the `state` argument supplied)
- newState: `String`
    (the new state after applying the changes)

All arguments need only be included if they have a non-empty value. The client
may keep trying to commit changes if the server returns notCreated, notUpdated
or notDestroyed responses, as these indicate temporary failures (e.g. because
the state doesn't match, so the client needs to fetch mailbox updates first
then apply the changes on top of the latest version, resolving any conflicts
before trying again). If the clientId is returned in the error argument
however, the client must discard the changes and rollback to the last known
good (committed) state.

Examples of permanent errors:

a) Attempt to delete an already deleted folder
b) Attempt to move a folder inside itself.
c) Attempt to move a folder into another one which already contains a
   folder of the same name.
d) Attempt to use illegal characters in a folder name. etc.

If there were creates in this commit, then *after* adding the mailboxesSet
response to the output, add the following response, with an entry
for each successfully created mailbox:

    ["updateMailboxes", {
      "<mailboxId>": {
        // If a shared folder, return the next two props.
        // Otherwise omitted, all permissions presumed true.
        "isOwn": false,
        "permissions": {...permissions obj...}
      },
      ...
    }]

### !Discussion points:

- Should "role" be read only?
- Should the folder name be restricted to only characters allowed in IMAP?
- Should a folder with a "role" not be allowed to be renamed, or moved inside another folder?

--------------------------------------------------------------------------------

## getMessageList

This method fetches (a section of) the list of message ids in a particular
mailbox or search.

### Arguments:

- mailboxId: `String`|`null`
- search: `String`
    (The query `String` to search with.)
- sort: `String`
    (Format: (uid|date|from|to|subject|size)(Descending|Ascending)(Flagged)?
     If 'Flagged' is on the end, flagged messages should be sorted before
     non-flagged messages.)
- useConversations: `Boolean`
    (If true, uses conversation mode to fetch the list; see description.)
- position: `Number`
    (position in message list (given sort and search) for first message,
     indexed from 0.)
- limit: `Number`
    (the maximum number of messages to retrieve)
- fetchMessages: `Array`|`null`
    (if not `null`, getMessages will be called with the message id list of the
     result. The array will be passed as the properties argument).
- fetchSearchPreviews: `Boolean`
    (if true, will make a call to getSearchMessagePreviews with the messageId
     list of the result.)

### Description:

1. If a mailbox id is given and there is no mailbox with that id, return a
   mailboxDoesNotExist error and exit the method.

2. Take the list of messages in the mailbox given (if a mailboxId is supplied)
   otherwise all messages for the user then remove those that do not match
   the search terms, if given.

3. Sort the message list in the direction given as a parameter.

4. Return the list of message ids for exemplars starting at the index given
   by the `position` argument, and returning up to `limit` results.

5. If the fetchMessages argument is not `null`, call getMessages using the
   following arguments:

   - properties: The fetchMessages argument from this call.
   - ids: the messageIds response from this call.
   - fetchConversations: The useConversations argument from this call.

6. If fetchSearchPreviews is true and search terms are specified, call
   `getSearchMessagePreviews` with the "search", "mailboxId" and "messageIds"
   arguments taken from the messageList response arguments of the same name.

Notes:
- The server may choose to enforce a maximum `limit` argument. This is safe
  to do since the total is returned, so the client should not be relying on
  how many results are returned to determine if it has reached the end of the
  mailbox.

Here is an example algorithm showing how conversations work (minus the parsing
of arguments and correct formatting of the response):

    let messageList = args.mailboxId ?
          mailbox[ args.mailboxId ] : allMessages;

    let sortedList = messageList.sortedBy( args.sort )
    let useConversations = args.useConversations

    let position = args.position
    let limit = args.limit
    let total = 0
    let messageIds = [] # NB Max size of array is limit

    let SeenExemplar =  useConversations ? empty set : null
    let numFound = 0

    # Optimisation for the common case where the total number of results is
    # already known (e.g. because it's the total number of messages/conversations
    # in the mailbox).
    let totalIsKnown = totalIsInCache( mailbox, useConversations )

    foreach msg in sortedList {
      if !useConversations || !SeenExemplar{ msg.conversationId } {

        total += 1

        if useConversations {
          SeenExemplar.set( msg.conversationId )
        }

        if position >= total && numFound < limit {
          messageIds.push( msg.id )
          numFound += 1
          if numFound == limit && totalIsKnown {
            break;
          }
        }
      }
    }

    if totalIsKnown {
      total = getTotalFromCache( mailbox, useConversations )
    }

    return [ messageIds, position, total, state ]

### Response name:

messageList

### Arguments:

- mailboxId: `String`
- sort: `String`
- search: `String`
- useConversations: `Boolean`
- position: `Number`
    (the position in the full filtered, sorted message list of the first message
     in the returned list (the rest are presumed sequential from here), indexed
     from 1)
- total: `Number`
    (total number of messages/conversations in the message list (depending on
     the useConversations argument))
- state: `String`
    (the current state of the message list. In IMAP servers, it is suggested
    this is the uidNext & highest modseq for the mailbox (see The email model
    in the introduction for a discussion). Should a client receive back a
    response with a different state string to a previous call with the same
    mailboxId/search parameters, it knows the list may have changed, and must
    either throw away the previous list and fetch it again (note, this does not
    require fetching the headers/bodies of the messages again, just the list of
    ids) or, if the server supports it, the client can call
    getMessageListUpdates with the state string.)
- messageIds: `Array<String>`
    (a subsection of the full filtered, sorted message list, starting at the
     position given by the start field and containing the maximum number of
     available messages up to the limit in the original method call)
- canCalculateUpdates: `Boolean`
    (does the server support calling getMessageListUpdates with these
    parameters. Note, this does not guarantee that the getMessageListUpdates
    call will succeed, as it may only be possible for a limited time afterwards
    due to server internal implementation details).

Note: Message ids are unique across the whole user. Thus, it is not a problem if messages are in multiple mailboxes (ala GMail), as after fetching the list, the client can easily determine if it already has the message header/body cached, and does not need to download it again. At FM, we currently use ids of the format `f${mailboxId}u${uid}`, but the actual structure is irrelevant to (and indeed must not be relied on by) the client.

### !Discussion points

- At FM, instead of specifying a position, you can also specify the section of
  the list you want returned by giving it a message id. If this message is in
  the list, the index of that message is used as the position argument. This is
  used by the FM webmail to locate where a particular message is in a mailbox
  when all it has is the ID (for example, when opening a bookmarked message).
  I've removed this as it seems of little use to most native clients, and over
  complicates things a bit. Thoughts?
- By returning a canCalculateUpdates response, different implementations can
  support delta updates for just mailboxes, mailboxes + some/all searches or not
  at all, depending on their internal data structures. Does this sound
  reasonable? At FM, we support it for mailbox listings, but not for searches.
- GMail doesn't support sorting by anything other than "dateDescending".
  Perhaps this should be part of a getCapabilities response as well.
- From the appearance of their web client at least, GMail's search
  infrastructure does not always know how many results there are (presumably
  because it doesn't allow sort by anything other than date descending, it has
  optimised internal data structures for searching just the newest messages
  until it has enough results). I don't have any great ideas for handling that
  right now; one of the nice things about this API is that it's the same doing
  a search as fetching a mailbox.
- The search in most implementations is expected to use an index; it will not
  be IMAP-style substring search. TODO: Specify a sane search syntax and
  flexible semantics.

--------------------------------------------------------------------------------

## getMessageListUpdates

This method allows you to efficiently fetch the changes that have happened to
the message list since your current state.

### Arguments:

- mailboxId: `String`
- search: `String`
- sort: `String`
    (uid|date|from|to|subject|size)(Descending|Ascending)(Flagged)?
- useConversations: `Boolean`
    (if true, uses conversation mode to fetch the updates)
- state: `String`
- uptoMessageId: `String`|`null`
    (The message id of the last message in the message list the client
    currently knows about; used to optimise updates when the client only has a
    partial cache of the message list – the server can not bother sending
    updates which the client doesn't need)
- maximumChanges: `Number`

### Example:

    ["getMessageListUpdates", {
      "mailboxId": "f12",
      "search": "",
      "sort": "dateDescending",
      "useConversations": true,
      "state": 'v3123l142m412',
      "uptoMessageId": 'f12u242'
    }]

### Description:

1. If a mailbox id is given and there is no mailbox with that id, return a
   "mailboxDoesNotExist" error and exit the method.

2. If the update cannot be calculated for the given arguments, for whatever
   reason, return a "cannotCalculateUpdates" error and exit the method.

3. Take the list of messages in the mailbox given (if a mailboxId is supplied)
   otherwise all messages for the user then remove those that do not match
   the search terms, if given.

4. Sort the message list in the direction given as a parameter.

5. Starting from the beginning of the list and continuing up to and including
   the message given in the uptoMessageId parameter (or if this is not
   found or not supplied then until the end of the list is reached), find:

   If useConversations == true

   a) the messageIds for messages that no longer represent their
      conversation (because the message has been deleted or another message
      with higher precedence in the current sort order has arrived).

   b) the messageIds and indexes of messages that newly represent a
      conversation in that view.

   Else if useConversations == false

   a) messages that have been deleted.

   b) messages have been appended to the mailbox.

6. If the number of messages in the added and removed arrays combined
   is greater than the maximumChanges argument given, return a tooManyChanges
   error; the client can instead wipe its cache and start again. Otherwise
   return an updateMessageList response as detailed below.

### Response name:

updateMessageList

### Arguments:

- mailboxId: `String`
- useConversations: `Boolean`
- oldState: `String`
   (echoed back from request)
- newState: `String`
   (the new state identifier the message list has been updated to)
- uptoMessageId: `String`
   (echoed back from request)
- sort: `String`
   (echoed back from the request)
- search: `String`
   (echoed back from the request)
- removed: `Array<String>`
   ('removed' array from algorithm below)
- added: List of two-element [`Number`, `String`] lists
   ('added' array from algorithm below. The number in each tuple is the index of
    the message in the list, starting from 0)
- total: `Number`
   (total number of conversations in the mailbox)
- userModSeq: `String`
   (the current global modseq for the user)

Example response:

    ["updateMessageList", {
      mailboxId: "f12"
      useConversations: true,
      oldState: "v3123l142m412",
      newState: "v3123l145m419",
      uptoMessageId: "f12u242",
      sort: 'dateDescending',
      search: '',
      removed: ["f12u53", "f12u125", "f12u136"],
      added: [[0, "f12u452"],[2, "f12u253"],[22, "f12u454"]],
      changed: ["c1", "c2", "c4"],
      total: 25
    }]

Implementation:

Here is an example algorithm for calculating step 4:

    let index = -1
    let added = []
    let removed = []
    let changed = []

    let useConversations = args.useConversations

    # A mutable search is one that contains a parameter which is mutable (i.e. a
    # flag). So for example a search for messages which are unread is mutable,
    # whereas a search for messages with "Joe Bloggs" in the From field is not.
    # Similarly, a mutable sort is one which sorts by a mutable property, e.g.
    # sort flagged messages/conversations first.
    let isMutable = search.isMutable() || sort.isMutable()
    let totalIsKnown = totalIsInCache( mailbox, search, useConversations )
    let uptoHasBeenFound = false

    let SeenExemplar = useConversations ? empty set : null
    let SeenOldExemplar = useConversations ? empty set : null

    # Mailbox includes expunged messages from the last week.
    let sortedMailbox = mailbox.sortedBy( args.sort );

    foreach msg in sortedMailbox {

      let isNewExemplar = false
      let isOldExemplar = false
      let inSearch = !search || search.matches( msg )

      let isNew = ( msg.uid >= args.uidNext )
      let isChanged = ( msg.modSeq > args.modSeq )
      let isDeleted = ( msg.flags & FLAG_EXPUNGED )
      let wasDeleted = ( isDeleted && !isChanged )

      # Is this message the current exemplar?
      if !isDeleted && inSearch &&
          ( !useConversations || !SeenExemplar{ msg.conversationId } ) {
        isNewExemplar = true
        index += 1
        if useConversations {
          SeenExemplar.set( msg.conversationId )
        }
      }

      # Optimisation for when the total is not known but we've hit the 'upto'
      # message
      if uptoHasBeenFound {
        continue
      }

      # Was this message an old exemplar, or in the case of mutable searches,
      # possibly an old exemplar?
      # 1. Must not have arrived after the client's state
      # 2. Must have been deleted before the client's state
      # 3. Must match search or search must be mutable (in which case, due to the
      #    restrictions detailed above, we must either not be grouping by
      #    conversation, or the mutable properties are conversation-wide
      #    properties. Either way, the first message we come to is the exemplar
      #    for that conversation.
      # 4. Must not have already found the old exemplar
      if !isNew && !wasDeleted && ( inSearch || search.isMutable() ) &&
          ( !useConversations || !SeenOldExemplar{ msg.conversationId } ) {
        isOldExemplar = true
        if useConversations {
          SeenOldExemplar.set( msg.conversationId )
        }
      }

      if isOldExemplar && !isNewExemplar {
        removed.push( msg.messageId )
      }
      else if !isOldExemplar && isNewExemplar {
        added.push( [ index, msg.messageId ] )
      }
      if !isNew {
        let modSeq = msg.modSeq
        # Has the message changed since the last update?
        if modSeq > args.modSeq {
          if isMutable && isOldExemplar && isNewExemplar {
            # We need to remove it from the client view (if there; we don't
            # know if it used to match the filter) and add it back in if it
            # now matches the filter. This will also fix mutable sorts, as
            # it will be added back in at the correct position, effectively
            # moving it to the correct place.
            removed.push( msg.messageId )
            added.push( [ index, msg.messageId ] )
          }
        }
      }

      # If this is the last message the client cares about, we can stop here
      # and just return what we've calculated so far. However, the 'total'
      # value returned MUST be correct; this should be possible as the total
      # values are being kept in a separate DB and updated as needed when
      # conversations change. If they're not, must continue to end of list (the
      # index variable + 1 will then be the total), but can still shortcut most
      # of the loop; only the bit that checks whether to increment index is
      # required.

      # If not mutable, can't break early either, as messages may have moved
      # from the region we care about to lower down the list.
      if !isMutable && msg.uid == args.upto {
        if totalIsKnown {
          break
        }
        else {
          uptoHasBeenFound = true
        }
      }

    } # End loop

    if totalIsKnown {
      total = getTotalFromCache( search, useConversations )
    } else {
      total = index + 1
    }

    return [ added, removed, total, state ]

Note! There is one case where this algorithm does not work, which is when
a) Conversation grouping is on. AND
b) Either the sort or search is on a mutable message property (i.e. search for
   messages with flag \X).

In this situation, any message in the mailbox is then potentially an old
exemplar. NB, it's OK if the sort and/or search is on a mutable
**conversation** property which has counts stored in the conversations DB
(i.e. search for messages within a conversation that has at least one
message with flag \X, or sort by flagged conversation).

The server should reject requests that cannot be calculated, rather
than returning bogus results. The canCalculateUpdates response of the
original getMessageList call should have been `false` so the client should
know it cannot fetch updates for that.

### How to apply the updates on the client:

Suppose the client will have a sparse list of messageIds:
e.g. `[ 'm1u1', 'm1u2', 'm1u3', 'm1u4', -, -, -, 'm1u8', -, ...]`

1. Check the oldState property matches the current state of the list. Also check
   the sort and search are the same. If any of these don't match, abort and
   re-request an update from the actual current state.
2. If the newState property is the same as the current state of the list,
   nothing to do, so return.
3. If there's an uptoMessageId, search for this id. If found, remove
   anything after it in the list. If not found, abort, reset the list and start
   again with getMailboxMessageList.
4. Search for each of the messageIds in the `removed` list and remove them
   from the client's list (without leaving a gap – this is a splice operation).
   If any can't be found, keep processing but after finishing, null out anything
   after the first gap in the list. e.g. referring to the example sparse list
   above, 'm1u8' would be removed as it's after the first gap.
5. Iterate through the [ position, messageId ] tuples in the `added` list
   in order, inserting the messageIds at the positions indicated.
6. Set the list length to that given in the `total` property.

Note, adding or removing an item to/from the list shifts the position of
everything around it.

e.g. adding 'm2' in position 2: `[ 'm1', 'm3' ] -> [ 'm1', 'm2', 'm3' ]`

e.g. removing 'm2': `[ 'm1', 'm2', 'm3' ] -> [ 'm1', 'm3' ]`

### !Discussion points
- At FM, we support getMessageListUpdates for mailbox listings, but not for
  searches (as the UID is per-folder, and it would need to be global).
- To implement this, the server must keep the metadata at least of deleted
  (expunged) messages for a little while. At FM, we keep them for 1-2 weeks
  (very useful for restoring accidentally deleted messages as well). At cleanup
  time (when actually removing the messages), the server must keep track of the
  highest modseq of a message it has removed in that mailbox (the modseq would
  have been set at the original delete time); any requests for updates from a
  state before this must be rejected, as the results may be incorrect.
- At FM, we have an extra parameter: fetchNewIfLessThan. These save a round
  trip by making an implicit call to getMessages to fetch the new message
  headers for the response. It's a bit convoluted though (and awkward to
  specify all the necessary arguments), so I've dropped it from this API spec
  for now.

--------------------------------------------------------------------------------

## getMessages

### Arguments:

- ids: `Array<String>`
    (a list of unique message ids)
- properties: `Array<String>`
    (a list of properties to fetch for email message)
- fetchConversations: `Boolean`

### Description:

For each message id specified in the ids parameter, the server should fetch
the parts/properties of the message requested in the properties parameter.

If any id in the list corresponds to a message which cannot be found (reasons
like the message being deleted, the decoded mailbox no longer existing,
the uid being higher than the max uid in the mailbox, etc.) then it should be
added to a missing list and the server should skip to the next id.

The following properties are returned in the format described below:

- *conversationId*: (`String`) The conversation id of the message
- *mailboxId*: (`String`) The mailbox id of the mailbox the message is in.
- *rawUrl*: (`String`) A url to download the original RFC8222 message from.
- *isUnread*: (`Boolean`) Is the message unread?
- *isFlagged*: (`Boolean`) Is the message flagged/starred?
- *isAnswered*: (`Boolean`) Has the message been replied to?
- *isDraft*: (`Boolean`) Is the message a draft?
- *hasAttachment*: (`Boolean`) Does the message have any attachments?
- *labels*: (`Array<String>`) An array of labels/keywords applied to the
  message.
- *from*: (`Array`|`null`) An array of name/email objects (see below)
  representing the parsed From header, if present (otherwise `null`). Note,
  although normally of length 1, technically this could be of length 0 or 2+.
- *to*: (`Array`|`null`) An array of name/email objects (see below) representing
  the parsed To header, if present (otherwise `null`).
- *cc*: (`Array`|`null`) An array of name/email objects (see below) representing
  the parsed CC header, if present (otherwise `null`).
- *bcc*: (`Array`|`null`) An array of name/email objects (see below)
  representing the parsed BCC header, if present (otherwise `null`).
- *replyTo*: (`Array`|`null`) An array of name/email objects (see below)
  representing the parsed Reply-To header, if present (otherwise `null`).
- *subject*: (`String`) The subject of the message
- *date*: (Date) The date the message was sent (or saved, if a draft).
- *size*: (`Number`) The size in bytes of the whole message.
- *preview*: (`String`) The first 120 characters of a plain text version of the
  body. This is intended to be shown as a preview line on a mailbox listing,
  and the server may choose to skip quoted sections or salutations to return
  a more useful preview.
- *textBody*: (`String`|`null`) Returns the plain text body part for the message
  if present
- *htmlBody*: (`String`|`null`) Returns the html body part for the message if
  present
- *body*: This is special in that there's no property called just "body" on
  the object returned. Instead, if there is an HTML part, it will return an
  "htmlBody" response, but if there is only a plain part, it will return a
  "textBody" response.
- *attachments*: (`Array`|`null`) An array of attachment objects (see below)
  describing all the attachments to the message.
- *attachedMessages*: (`Object`|`null`) Returns an object mapping attachment id
  (as found in the attachments response) to a message object with all the
  same properties requested for this message, for every attached message
  (flag properties are ignored).

An attachment object looks like this:

    {
      id: String,
      url: String,  // A url to download the attachment
                    // (requires same authentication mechanism)
      type: String, // The MIME type of the attachment.
      name: String, // The full file name, e.g. 'myworddocument.doc'
      size: Number, // Size in bytes
      isInline: Boolean, // True if the attachment is referenced by a cid link
                         // from within the HTML body.
      width: Number, // (optional) Width (in px) of image.
      height: Number // (optional) Height (in px) of image.
    }

The from/to/cc/bcc/replyTo fields are parsed into an array of objects like so:

    [{name:"Joe Bloggs", email:"joe@bloggs.com"},
     {name:"John Smith", email:"john@smith.com"}]

If a name cannot be extracted for an email, the name property of the object
should be the empty string.

Any property asked for that is not in the list above should be interpreted as
a request for the header of the same name, and should be returned as a string.
Note, this is case-sensitive, thus requesting "To" would return the raw To header, whereas requesting "to", returns the parsed version as specified
above.

If fetchConversations is true, after returning the `messages` response, a
call should be made to getConversations with the conversationId of each of
the returned messages as the ids argument.

### Response name:

messages

### Arguments:

- state: `String`
    (this string will change whenever any message is added/removed/changed
     for the user. It can be passed to getMessageUpdates.)
- list: `Array` of `Message Object`s
    (an array of message objects containing the messageId plus the requested
     properties)
- missing: `Array` of `String` (optional)
    (a list of message ids which were requested, but could not be found)

### Example

Request:

    ["getMessages", {
      "ids": [ "f123u456", "f123u457" ],
      "properties": [ "conversationId", "mailboxId", "from", "subject", "date" ]
    }, "#1"]

Response:

    ["messages", {
      "state": "41234123231",
      "list": [
        {
          messageId: "f123u457",
          conversationId: "ef1314a",
          mailboxId: "f123",
          from: [{name: "Joe Bloggs", email: "joe@bloggs.com"}],
          subject: "Dinner on Thursday?",
          date: "2013-10-13T14:12:00Z"
        }
      ],
      missing: [ "f123u456" ]
    }, "#1"]

### !Discussion points

- In Cyrus, header data is held in a cache for fast access, so the client will
  be faster if it just requests the fields it needs to display the mailbox,
  then fetches the rest (including the body) later, however there's flexibility
  here for more basic clients to simply fetch everything they want upfront and
  not do anything complex.
- Labels in IMAP are very limited (no spaces, short maximum length, no foreign
  characters) Perhaps we should be returning label ids here, and have separate
  (get|set)Labels methods to map the ids to names (this makes them possible to
  rename across all messages as well).
- In GMail, mailboxes are (mostly) labels, so if a message has more than one
  label, I think the mailboxId for the message should = the id for the "All
  mail" mailbox (the only one that isn't a label!).
- At FM, we have an extra argument called "unreadFlaggedDraftAndNewestOnly",
  which restricts the set of returned message details to just those which are
  unread, flagged, a draft or the newest message in the conversation. This is
  a specific optimisation for not loading messages which will be collapsed when
  the user opens the conversation in our web UI, so I removed it.
- At FM, we "defang" the HTML (remove any malicious scripts etc.) at this point
  before returning it to the client. We also extract out any `<style>` tags in
  the HTML and return them as a separate property on the object. This seemed
  all a bit too specific for a general API, so in this spec I think we should
  return the original HTML from the message.
- The fetchConversations argument removes a roundtrip required before the
  mailbox list can be displayed when using conversation mode.

--------------------------------------------------------------------------------

## getConversations

### Arguments:

- ids: `Array<String>` // Array of conversation ids

Example:

    [ "getConversations", {
      "ids": ["f123u4", "f41u44"]
    }]

### Description:

Look up the list of messages in the conversation, sorted oldest first, the
from address of each message in the conversation, and the flags that are set
on each message in the conversation.

Any conversation ids that cannot be found should be returned in the optional
missing argument.

### Response name:

conversations

### Arguments:

- state: `String`
    (this string will change whenever any message is added/removed/changed
     for the user. It can be passed to getMessageUpdates.)
- list: `Array` of `Conversation Object`s
- missing: `Array` of `String (optional)
    (the conversation ids requested which cannot be found)

Where a Conversation Object is:

    {
      conversationId: String,
      messages: [
        {
          messageId: String,
          isUnread: Boolean,
          isFlagged: Boolean,
          isAnswered: Boolean,
          isDraft: Boolean,
          hasAttachment: Boolean,
          from: Array // { name: String, email: String }
        },
        …
      ],
      size: Number // Total size of messages in conversation, in bytes.
    }

--------------------------------------------------------------------------------

## getMessageUpdates

### Arguments

- state: `String`
- maximumChanges: `Number`

### Description

This fetches the following:

1. The list of all message ids for message which have been modified.
2. The list of all conversation ids for messages which have been modified.
3. The list of all mailbox ids containing messages which have been modified.

If the number of message ids exceeds the maximumChanges argument, return
a "tooManyChanges" error, otherwise return the lists of ids.

The client can use this to work out which messages/conversations it needs to
refetch after it detects a change (either by the new modseq being pushed, or by
it noticing a difference in user-modseq returned with another method), and
which mailbox message lists it needs to refresh.

### Response name:
  messageUpdates

### Arguments:
- oldState: `String`
    (echoed back from request)
- newState: `String`
    (the current state)
- messageIds: `Array<conversationId>`
    (array of message ids for messages that have changed)
- conversationIds: `Array<conversationId>`
    (array of conversation ids for conversations containing changed messages)
- mailboxIds: `Array<conversationId>`
    (array of mailbox ids for mailboxes containing changed messages)

--------------------------------------------------------------------------------

## getSearchMessagePreviews

### Arguments:
- ids: `Array<String>`
- search: `String`
- mailboxId: `String`|`null`

### Description:

This method fetches previews of messages when a search is in progress, with
relevent parts of the preview highlighted.

For each id in the messageIds:

1. Create an empty preview object.

2. Fetch the message. If found:

a) If there is a search, find the section of message body that matches the
   supplied search terms. If this exists, HTML escape it, then highlight the
   search terms in it by wrapping them in `<b></b>` tags and add this as the
   "body" property of the preview object.

   Otherwise, add the first 120(?) characters of the body, HTML escaped.

b) If there is a search and the subject matches the search term, HTML escape
   it, then highlight the search terms in it by wrapping them in `<b></b>` tags
   and add this as the "subject" property of the preview object.

3. Add the preview object to the "previews" output object, using the
   messageId as the key.

### Response name:
  messagePreviews

### Arguments:
- search: `String`
    (echoed back from request)
- mailboxId: `String`|`null`
    (echoed back from request)
- previews: Object
    (maps each messageId from request to an object with optional "body"
     and "subject" properties)
- userModSeq: `String`
   (the current global modseq for the user)

Example response:

    [ "messagePreviews", {
      "search": "bar",
      "mailboxId": null,
      "previews": {
        "f123u456": {
          "body": "foo <b>bar</b> &lt;one&rt;"
        },
        "f654u14": {
          "body": "... love this <b>bar</b>; let's go tonight.",
          "subject": "Want to go to the <b>bar</b>?"
        },
        "f521u11": {
          "body": "Hi Jane. What do you say to a jolly old adventure down th"
        }
      }
    }]



3. Mailbox/conversation action APIs
===================================

### !Discussion points
- Since the state of the server mailboxes may be different to the current state
  in the client, these commands are all optimistic: they execute as best they
  can then the client is expected to use the getMessageListUpdates method to
  check the new state. The client may make optimistic UI changes immediately
  based on the expected result of getMessageListUpdates and then make any
  necessary changes when the response arrives.
- At FM, we have an extra parameter to each of these methods:
  "applyToConversation", which can be one of three values: "yes", "no",
  "mailbox". This applies the action to respectively: all messages in the same
  conversation as any of the message ids given, all messages in the same
  conversation and same mailbox as any of the message ids given, or just the
  message ids given. This is useful for doing actions on conversations without
  having to call "getConversations" on everything first, however it makes it a
  bit more uncertain about what is actually going to happen, so for now I've
  left it out.
- We might want to add an option to pass in the userModSeq (returned by the get
  commands) and have the method optionally refuse to execute if it does not
  match the user's current state, so a client has the option of guaranteeing
  the state it is acting upon.

--------------------------------------------------------------------------------

## deleteMessages

### Arguments:
- messageIds: `Array<String>`

### Description:
  For each message referenced in messageIds:
  - If the message doesn't exist, add it to a missing list.
  - Otherwise, permanently delete the message.

### Response name:
  messagesDeleted

### Arguments:
- deleted: `Array<messageId>`
    (list of messageIds for every message that was deleted)
- missing: `Array<messageId>` (optional)

Example response:

    [ "messagesDeleted", {
        "deleted": [ "f123u456", "f312u142" ]
    }]

--------------------------------------------------------------------------------

## moveMessages

### Arguments:
- messageIds: `Array<String>`
- destinationMailboxId: `String`

### Description:
  1. If destinationMailboxId does not correspond to a valid mailbox id, output
     a "mailboxNotFound" error and exit the method.

  2. For each message referenced in messageIds:
     - If the message doesn't exist, add it to a missing list.
     - Otherwise, move each message in the list to the mailbox with id
       destinationMailboxId.

### Response name:
  messagesMoved

### Arguments:
- moved: oldMessageId -> newMessageId map
- missing: `Array<messageId>` (optional)

Note, the new message id may be the same as the old id (in systems using a
per-user uid system or when you attempt to move a message to the mailbox it's
already in).

Example response:

    [ "messagesMoved", {
        "moved": {
          "f146u456": "f43u41",
          "f146u51": "f43u42"
          "f146u67": "f51u512",
          "f146u95": "f51u513"
        }
    }]

### !Discussion point
- Deletion is a move to the trash folder (there is no \Deleted flag in this API)
- At FM, we keep track of which folder a message was deleted from, so that we can restore that message to the original folder if the user undeletes it (we have a specific extra API method for this: "restoreMessages"). Is this something we should consider adding to a general API?

--------------------------------------------------------------------------------

## copyMessages

### Arguments:
- messageIds: `Array<String>`
- destinationMailboxId: `String`

### Description:
  1. If destinationMailboxId does not correspond to a valid mailbox id, output
     a "mailboxNotFound" error and exit the method.

  2. For each message referenced in messageIds:
     - If the message doesn't exist, add it to a missing list.
     - Otherwise, copy each message in the list to the mailbox with id
       destinationMailboxId.

### Response name:
  messagesCopied

### Arguments:
- destinationMailboxId: `String`
    (echoed back from request)
- copied: sourceMessageId -> copiedMessageId map
    (same as moveMessages response, except old message still exists)
- missing: `Array<messageId>` (optional)

Note, on some systems (GMail), copying to another mailbox will not copy the
message, but simply add another label. In this case, the message in the new
destination will have the same id as the original message; this can be seen tin
the response.

### Discussion points
- What to do if copying takes user over quota?

--------------------------------------------------------------------------------

## setMessagesProperty

### Arguments:
- property: `String`
  ('isUnread' or 'isFlagged')
- value: `Boolean`
- messageIds: `Array<String>`

### Description:
  For each message referenced in messageIds:
  - If the message doesn't exist, add it to a missing list.
  - Otherwise set or remove the flag specified by the property argument
    according to the value argument.

### Response name:
  messagesPropertySet

### Arguments:
- property: `String`
    (echoed back from request)
- value: `Boolean`
    (echoed back from request)
- changed: `Array<messageId>`
    (list of all message whose property changed)
- missing: `Array<messageId>` (optional)

### !Discussion points
- This should also set/remove labels as well, but I haven't yet thought about
  the best way to do this in the API.

--------------------------------------------------------------------------------

## reportMessages

### Arguments:
- messageIds: `Array<String>`
- asSpam: `Boolean`

### Description:
  For each message referenced in messageIds:
  - If the message doesn't exist, add it to a missing list.
  - Otherwise, if register the message as spam/not spam (depending on the
    asSpam argument) with any appropriate database/feedback service.

### Response name:
 messagesReported

### Arguments:
- asSpam: `Boolean`
- changed: `Array<messageId>`
- missing: `Array<messageId>` (optional)

Notes:
  This doesn't automatically move messages in/out of the Junk folder. This
  method will therefore almost always be immediately followed by a moveMessages
  call.

Errors
======

If an error response is specified in the spec, it is to be added to the response
instead of any other output from that method (so no half output + an error). An error response, is a message called "error", with arguments, "method" (the method that was called), "arguments" (the arguments that were given) and type (the error type, as specified in the methods above).

Example:

    ["error", {
      "type": "tooManyChanges",
      "method": "getMessageListUpdates",
      "arguments": {
        "mailboxId": "f12",
        "search": "",
        "sort": "dateDescending",
        "useConversations": true,
        "state": 'v3123l142m412',
        "uptoMessageId": 'f12u242',
        "fetchUpdates": true,
        "fetchNewIfLessThan": 10
      }
    }, "#1"]
